ä¸ºä½ çš„MCPå·¥å…·æ·»åŠ **è‡ªåŠ¨æ‰“å¼€Word/WPSåŠŸèƒ½**ç¡®å®èƒ½æå¤§æå‡ç”¨æˆ·ä½“éªŒã€‚ä»¥ä¸‹æ˜¯è·¨å¹³å°çš„å®Œæ•´å®ç°æ–¹æ¡ˆï¼š
åœ¨D:\projects\mdMCP\src\servicesæ–°å»ºappLauncheræ–‡ä»¶å¤¹ï¼Œæ–‡ä»¶å¤¹åŒ…å«ä»¥ä¸‹æ–‡ä»¶ï¼š
- appLauncher.tsï¼šåº”ç”¨å¯åŠ¨å™¨ä¸»ç±»
- documentOpener.tsï¼šæ™ºèƒ½æ–‡æ¡£æ‰“å¼€å™¨
- platformUtils.tsï¼šå¹³å°ç›¸å…³å·¥å…·å‡½æ•°
- appConfig.tsï¼šåº”ç”¨é…ç½®ç®¡ç†

## ğŸŒ è·¨å¹³å°è‡ªåŠ¨æ‰“å¼€æ–¹æ¡ˆ

### 1. **æ ¸å¿ƒå®ç°ç±»ï¼šæ™ºèƒ½æ–‡æ¡£æ‰“å¼€å™¨**

```typescript
// src/utils/DocumentOpener.ts
import { exec, spawn } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import * as path from 'path';
import { fileTypeFromFile } from 'file-type';

const execAsync = promisify(exec);

export interface OpenOptions {
  wait?: boolean;      // æ˜¯å¦ç­‰å¾…ç¨‹åºå…³é—­
  silent?: boolean;    // æ˜¯å¦é™é»˜æ‰“å¼€ï¼ˆä¸æ˜¾ç¤ºçª—å£ï¼‰
  args?: string[];     // é¢å¤–å‚æ•°
}

export class IntelligentDocumentOpener {
  private platform: NodeJS.Platform;
  private defaultApps: Map<string, string> = new Map();

  constructor() {
    this.platform = process.platform;
    this.initializeDefaultApps();
  }

  /**
   * åˆå§‹åŒ–å„å¹³å°é»˜è®¤åº”ç”¨æ£€æµ‹
   */
  private async initializeDefaultApps(): Promise<void> {
    switch (this.platform) {
      case 'win32':
        await this.detectWindowsApps();
        break;
      case 'darwin':
        await this.detectMacApps();
        break;
      case 'linux':
        await this.detectLinuxApps();
        break;
    }
  }

  /**
   * æ™ºèƒ½æ‰“å¼€æ–‡æ¡£ - ä¸»æ–¹æ³•
   */
  async openDocument(filePath: string, options: OpenOptions = {}): Promise<OpenResult> {
    // éªŒè¯æ–‡ä»¶å­˜åœ¨ä¸”å¯è¯»
    await this.validateFile(filePath);
    
    // è·å–æ–‡ä»¶ç±»å‹
    const fileType = await this.detectFileType(filePath);
    
    // é€‰æ‹©æœ€ä½³æ‰“å¼€æ–¹å¼
    const openStrategy = await this.chooseOpenStrategy(filePath, fileType);
    
    // æ‰§è¡Œæ‰“å¼€
    return await this.executeOpen(openStrategy, options);
  }

  /**
   * éªŒè¯æ–‡ä»¶
   */
  private async validateFile(filePath: string): Promise<void> {
    try {
      await fs.access(filePath, fs.constants.R_OK);
    } catch {
      throw new Error(`æ–‡ä»¶ä¸å­˜åœ¨æˆ–ä¸å¯è¯»: ${filePath}`);
    }
  }

  /**
   * æ£€æµ‹æ–‡ä»¶ç±»å‹
   */
  private async detectFileType(filePath: string): Promise<string> {
    const ext = path.extname(filePath).toLowerCase();
    
    // å¸¸è§æ–‡æ¡£ç±»å‹æ˜ å°„
    const typeMap: Record<string, string> = {
      '.docx': 'word',
      '.doc': 'word',
      '.xlsx': 'excel',
      '.xls': 'excel',
      '.pptx': 'powerpoint',
      '.ppt': 'powerpoint',
      '.pdf': 'pdf',
      '.txt': 'text',
      '.md': 'markdown'
    };
    
    return typeMap[ext] || 'unknown';
  }
}
```

### 2. **Windowså¹³å°å®ç°ï¼ˆæœ€å¸¸ç”¨ï¼‰**

```typescript
// Windowsç‰¹å®šå®ç°
private async detectWindowsApps(): Promise<void> {
  const apps = [
    // æ£€æµ‹WPS
    {
      name: 'WPS Office',
      paths: [
        'C:\\Program Files\\WPS Office\\ksolaunch.exe',
        'C:\\Program Files (x86)\\WPS Office\\ksolaunch.exe',
        process.env.LOCALAPPDATA + '\\Kingsoft\\WPS Office\\ksolaunch.exe'
      ],
      checkCommand: 'reg query "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wps.exe"'
    },
    // æ£€æµ‹Microsoft Office
    {
      name: 'Microsoft Word',
      paths: [
        'C:\\Program Files\\Microsoft Office\\root\\Office16\\WINWORD.EXE',
        'C:\\Program Files (x86)\\Microsoft Office\\root\\Office16\\WINWORD.EXE',
        'C:\\Program Files\\Microsoft Office\\Office15\\WINWORD.EXE'
      ],
      checkCommand: 'reg query "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\WINWORD.EXE"'
    },
    // æ£€æµ‹Office 365
    {
      name: 'Office 365',
      paths: [
        `${process.env.LOCALAPPDATA}\\Microsoft\\WindowsApps\\WINWORD.EXE`
      ]
    }
  ];

  for (const app of apps) {
    if (await this.checkWindowsAppExists(app)) {
      this.defaultApps.set('word', app.paths[0]);
      break;
    }
  }
}

/**
 * æ£€æŸ¥Windowsåº”ç”¨æ˜¯å¦å­˜åœ¨
 */
private async checkWindowsAppExists(app: WindowsApp): Promise<boolean> {
  try {
    // æ–¹æ³•1ï¼šæ£€æŸ¥æ³¨å†Œè¡¨
    if (app.checkCommand) {
      await execAsync(app.checkCommand);
      return true;
    }
    
    // æ–¹æ³•2ï¼šæ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    for (const appPath of app.paths) {
      try {
        await fs.access(appPath);
        return true;
      } catch {
        continue;
      }
    }
  } catch {
    return false;
  }
  return false;
}

/**
 * Windowsæ‰“å¼€å®ç°
 */
private async openWindows(filePath: string, options: OpenOptions): Promise<OpenResult> {
  const normalizedPath = path.resolve(filePath).replace(/\//g, '\\');
  
  // æ–¹æ³•1ï¼šä½¿ç”¨startå‘½ä»¤ï¼ˆæœ€å¯é ï¼‰
  try {
    const command = options.wait 
      ? `start /wait "" "${normalizedPath}"`
      : `start "" "${normalizedPath}"`;
    
    await execAsync(command, { shell: true });
    return { success: true, method: 'start-command' };
  } catch (error) {
    console.warn('startå‘½ä»¤å¤±è´¥:', error);
  }
  
  // æ–¹æ³•2ï¼šä½¿ç”¨explorer
  try {
    await execAsync(`explorer "${normalizedPath}"`);
    return { success: true, method: 'explorer' };
  } catch (error) {
    console.warn('exploreræ‰“å¼€å¤±è´¥:', error);
  }
  
  // æ–¹æ³•3ï¼šä½¿ç”¨é»˜è®¤åº”ç”¨è·¯å¾„
  const defaultApp = this.defaultApps.get('word');
  if (defaultApp) {
    try {
      const args = options.args || [];
      const process = spawn(defaultApp, [normalizedPath, ...args], {
        detached: true,
        stdio: 'ignore'
      });
      process.unref();
      return { success: true, method: 'direct-executable' };
    } catch (error) {
      console.warn('ç›´æ¥æ‰§è¡Œå¤±è´¥:', error);
    }
  }
  
  throw new Error('æ— æ³•æ‰“å¼€æ–‡æ¡£ï¼Œè¯·æ£€æŸ¥æ˜¯å¦å®‰è£…äº†Wordæˆ–WPS');
}
```

### 3. **macOSå¹³å°å®ç°**

```typescript
/**
 * macOSæ‰“å¼€å®ç°
 */
private async openMacOS(filePath: string, options: OpenOptions): Promise<OpenResult> {
  const normalizedPath = path.resolve(filePath);
  
  // æ–¹æ³•1ï¼šä½¿ç”¨openå‘½ä»¤ï¼ˆæœ€ä½³ï¼‰
  try {
    const args = ['open', normalizedPath];
    if (options.wait) args.push('-W');
    if (options.silent) args.push('-j');
    
    await execAsync(args.join(' '));
    return { success: true, method: 'open-command' };
  } catch (error) {
    console.warn('openå‘½ä»¤å¤±è´¥:', error);
  }
  
  // æ–¹æ³•2ï¼šä½¿ç”¨ç‰¹å®šåº”ç”¨æ‰“å¼€
  const apps = [
    '/Applications/Microsoft Word.app',
    '/Applications/WPS Office.app',
    '/Applications/LibreOffice.app'
  ];
  
  for (const app of apps) {
    try {
      await fs.access(app);
      await execAsync(`open -a "${app}" "${normalizedPath}"`);
      return { success: true, method: 'specific-app' };
    } catch {
      continue;
    }
  }
  
  throw new Error('æœªæ‰¾åˆ°å¯ç”¨çš„æ–‡æ¡£ç¼–è¾‘è½¯ä»¶');
}

private async detectMacApps(): Promise<void> {
  const apps = [
    '/Applications/Microsoft Word.app',
    '/Applications/WPS Office.app',
    '/Applications/LibreOffice.app',
    '/Applications/Pages.app'
  ];
  
  for (const app of apps) {
    try {
      await fs.access(app);
      this.defaultApps.set('word', app);
      break;
    } catch {
      continue;
    }
  }
}
```

### 4. **Linuxå¹³å°å®ç°**

```typescript
/**
 * Linuxæ‰“å¼€å®ç°
 */
private async openLinux(filePath: string, options: OpenOptions): Promise<OpenResult> {
  const normalizedPath = path.resolve(filePath);
  
  // æ–¹æ³•1ï¼šä½¿ç”¨xdg-openï¼ˆæ¡Œé¢ç¯å¢ƒæ ‡å‡†ï¼‰
  try {
    const command = `xdg-open "${normalizedPath}"`;
    if (options.wait) {
      await execAsync(command);
    } else {
      // éé˜»å¡æ‰§è¡Œ
      spawn('xdg-open', [normalizedPath], {
        detached: true,
        stdio: 'ignore'
      }).unref();
    }
    return { success: true, method: 'xdg-open' };
  } catch (error) {
    console.warn('xdg-openå¤±è´¥:', error);
  }
  
  // æ–¹æ³•2ï¼šå°è¯•ç‰¹å®šåº”ç”¨
  const apps = [
    'wps', 'libreoffice', 'soffice', 'onlyoffice',
    'xdg-open', 'gnome-open', 'kde-open'
  ];
  
  for (const app of apps) {
    try {
      await execAsync(`which ${app}`);
      const process = spawn(app, [normalizedPath], {
        detached: true,
        stdio: 'ignore'
      });
      process.unref();
      return { success: true, method: app };
    } catch {
      continue;
    }
  }
  
  throw new Error('è¯·å®‰è£…WPSã€LibreOfficeæˆ–OnlyOffice');
}
```

### 5. **é›†æˆåˆ°MCPå·¥å…·**

```typescript
// åœ¨MCPæœåŠ¡å™¨ä¸­é›†æˆ
import { IntelligentDocumentOpener } from './utils/DocumentOpener.js';

class EnhancedMcpServer {
  private documentOpener: IntelligentDocumentOpener;
  
  constructor() {
    this.documentOpener = new IntelligentDocumentOpener();
    this.registerOpenTools();
  }
  
  private registerOpenTools(): void {
    // æ·»åŠ æ‰“å¼€å·¥å…·
    this.tools.push({
      name: 'open_document',
      description: 'ä½¿ç”¨é»˜è®¤åº”ç”¨æ‰“å¼€æ–‡æ¡£',
      inputSchema: {
        type: 'object',
        properties: {
          filePath: { type: 'string' },
          waitForClose: { type: 'boolean', default: false },
          bringToFront: { type: 'boolean', default: true }
        },
        required: ['filePath']
      }
    });
    
    // æ·»åŠ è½¬æ¢å¹¶æ‰“å¼€å·¥å…·
    this.tools.push({
      name: 'convert_and_open',
      description: 'è½¬æ¢Markdownä¸ºWordå¹¶ç«‹å³æ‰“å¼€',
      inputSchema: {
        type: 'object',
        properties: {
          markdownPath: { type: 'string' },
          autoSync: { type: 'boolean', default: true }
        },
        required: ['markdownPath']
      }
    });
  }
  
  /**
   * å¤„ç†æ‰“å¼€æ–‡æ¡£è¯·æ±‚
   */
  private async handleOpenDocument(args: {
    filePath: string;
    waitForClose?: boolean;
    bringToFront?: boolean;
  }): Promise<ToolResult> {
    try {
      const result = await this.documentOpener.openDocument(args.filePath, {
        wait: args.waitForClose
      });
      
      return {
        content: [{
          type: 'text',
          text: `âœ… æ–‡æ¡£å·²æ‰“å¼€\n` +
                `æ–‡ä»¶: ${path.basename(args.filePath)}\n` +
                `æ–¹å¼: ${result.method}\n` +
                `åº”ç”¨: ${this.getFriendlyAppName(result)}`
        }]
      };
    } catch (error) {
      return {
        content: [{
          type: 'text',
          text: `âŒ æ‰“å¼€å¤±è´¥: ${error.message}\n\n` +
                `å»ºè®®:\n` +
                `1. æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡®\n` +
                `2. ç¡®è®¤å·²å®‰è£…Word/WPS/LibreOffice\n` +
                `3. å°è¯•æ‰‹åŠ¨æ‰“å¼€æ–‡ä»¶`
        }],
        isError: true
      };
    }
  }
  
  /**
   * è½¬æ¢å¹¶ç«‹å³æ‰“å¼€
   */
  private async handleConvertAndOpen(args: {
    markdownPath: string;
    autoSync?: boolean;
  }): Promise<ToolResult> {
    // 1. å…ˆè½¬æ¢
    const wordPath = args.markdownPath.replace(/\.md$/i, '.docx');
    await this.converter.markdownToDocx(args.markdownPath, wordPath);
    
    // 2. å»ºç«‹åŒæ­¥ï¼ˆå¦‚æœéœ€è¦ï¼‰
    if (args.autoSync) {
      await this.syncManager.watchPair(args.markdownPath, wordPath);
    }
    
    // 3. æ‰“å¼€æ–‡æ¡£
    const openResult = await this.documentOpener.openDocument(wordPath);
    
    return {
      content: [{
        type: 'text',
        text: `ğŸ‰ å®Œæˆï¼\n\n` +
              `è½¬æ¢: ${path.basename(args.markdownPath)} â†’ ${path.basename(wordPath)}\n` +
              `åŒæ­¥: ${args.autoSync ? 'å·²å¯ç”¨' : 'æœªå¯ç”¨'}\n` +
              `çŠ¶æ€: æ–‡æ¡£å·²${openResult.success ? 'æ‰“å¼€' : 'æ‰“å¼€å¤±è´¥'}\n\n` +
              `ç°åœ¨ä½ å¯ä»¥ï¼š\n` +
              `1. åœ¨Wordä¸­ç¼–è¾‘å¹¶è‡ªåŠ¨åŒæ­¥å›Markdown\n` +
              `2. å…³é—­Wordåç»§ç»­åœ¨Markdownä¸­å·¥ä½œ\n` +
              `3. ä½¿ç”¨ \`stop_sync\` å‘½ä»¤åœæ­¢åŒæ­¥`
      }]
    };
  }
}
```

### 6. **CLIå¢å¼º**

```typescript
// æ‰©å±•CLIå‘½ä»¤
program
  .command('open <file>')
  .description('ç”¨é»˜è®¤åº”ç”¨æ‰“å¼€æ–‡æ¡£')
  .option('-w, --wait', 'ç­‰å¾…åº”ç”¨å…³é—­')
  .option('-a, --app <name>', 'æŒ‡å®šåº”ç”¨ï¼ˆword, wps, libreofficeï¼‰')
  .action(async (file, options) => {
    const opener = new IntelligentDocumentOpener();
    
    console.log(`æ­£åœ¨æ‰“å¼€: ${file}`);
    console.log(`å¹³å°: ${process.platform}`);
    
    const result = await opener.openDocument(file, {
      wait: options.wait,
      args: options.app ? ['--app', options.app] : undefined
    });
    
    console.log(`âœ… æ‰“å¼€æˆåŠŸ (æ–¹å¼: ${result.method})`);
  });

program
  .command('convert-open <markdown-file>')
  .description('è½¬æ¢Markdownä¸ºWordå¹¶ç«‹å³æ‰“å¼€')
  .option('--no-sync', 'ä¸å»ºç«‹åŒæ­¥')
  .option('--no-open', 'åªè½¬æ¢ä¸æ‰“å¼€')
  .action(async (mdFile, options) => {
    // æ˜¾ç¤ºè¿›åº¦
    const spinner = createSpinner('æ­£åœ¨è½¬æ¢...').start();
    
    // è½¬æ¢
    const wordFile = mdFile.replace(/\.md$/i, '.docx');
    await converter.markdownToDocx(mdFile, wordFile);
    spinner.text = 'è½¬æ¢å®Œæˆï¼Œæ­£åœ¨æ‰“å¼€...';
    
    // åŒæ­¥
    if (options.sync) {
      syncManager.watchPair(mdFile, wordFile);
      spinner.text = 'åŒæ­¥å·²å»ºç«‹ï¼Œæ­£åœ¨æ‰“å¼€...';
    }
    
    // æ‰“å¼€
    if (options.open) {
      const opener = new IntelligentDocumentOpener();
      await opener.openDocument(wordFile);
      spinner.succeed(`å®Œæˆï¼å·²æ‰“å¼€ ${path.basename(wordFile)}`);
    } else {
      spinner.succeed(`è½¬æ¢å®Œæˆ: ${path.basename(wordFile)}`);
    }
    
    // æ˜¾ç¤ºåç»­æ“ä½œæç¤º
    if (options.sync) {
      console.log('\nğŸ“‹ åç»­æ“ä½œ:');
      console.log('1. åœ¨Wordä¸­ç¼–è¾‘ â†’ è‡ªåŠ¨ä¿å­˜åˆ°Markdown');
      console.log('2. åœ¨Markdownä¸­ç¼–è¾‘ â†’ è‡ªåŠ¨æ›´æ–°Word');
      console.log('3. ä½¿ç”¨ `mdsync status` æŸ¥çœ‹åŒæ­¥çŠ¶æ€');
    }
  });
```

### 7. **æ•…éšœå¤„ç†ä¸é™çº§æ–¹æ¡ˆ**

```typescript
/**
 * æ™ºèƒ½é™çº§ç­–ç•¥
 */
class SmartDocumentOpener extends IntelligentDocumentOpener {
  async openWithFallback(filePath: string, options: OpenOptions): Promise<OpenResult> {
    const strategies = [
      this.openWithDefaultApp.bind(this),
      this.openWithSystemCommand.bind(this),
      this.openWithBrowser.bind(this), // é™çº§åˆ°æµè§ˆå™¨æŸ¥çœ‹
      this.openWithTextEditor.bind(this) // é™çº§åˆ°æ–‡æœ¬ç¼–è¾‘å™¨
    ];
    
    for (const strategy of strategies) {
      try {
        return await strategy(filePath, options);
      } catch (error) {
        console.warn(`ç­–ç•¥å¤±è´¥: ${error.message}`);
        continue;
      }
    }
    
    // æœ€ç»ˆé™çº§ï¼šæ˜¾ç¤ºæ–‡ä»¶ä½ç½®
    await this.showFileLocation(filePath);
    return { success: false, method: 'show-location' };
  }
  
  /**
   * é™çº§æ–¹æ¡ˆï¼šåœ¨æµè§ˆå™¨ä¸­æŸ¥çœ‹
   */
  private async openWithBrowser(filePath: string): Promise<OpenResult> {
    if (path.extname(filePath) === '.docx') {
      // å¯¹äºdocxï¼Œå¯ä»¥è½¬æ¢ä¸ºHTMLåœ¨æµè§ˆå™¨ä¸­æŸ¥çœ‹
      const htmlPath = await this.convertToHtml(filePath);
      return await this.openWithDefaultApp(htmlPath);
    }
    throw new Error('ä¸æ”¯æŒåœ¨æµè§ˆå™¨ä¸­æŸ¥çœ‹æ­¤æ–‡ä»¶ç±»å‹');
  }
  
  /**
   * æ˜¾ç¤ºæ–‡ä»¶ä½ç½®
   */
  private async showFileLocation(filePath: string): Promise<void> {
    const absolutePath = path.resolve(filePath);
    
    switch (this.platform) {
      case 'win32':
        await execAsync(`explorer /select,"${absolutePath}"`);
        break;
      case 'darwin':
        await execAsync(`open -R "${absolutePath}"`);
        break;
      case 'linux':
        await execAsync(`xdg-open "${path.dirname(absolutePath)}"`);
        break;
    }
  }
}
```

### 8. **ä½¿ç”¨ç¤ºä¾‹**

```typescript
// åœ¨MCPå·¥å…·ä¸­çš„è°ƒç”¨ç¤ºä¾‹
const opener = new IntelligentDocumentOpener();

// ç®€å•æ‰“å¼€
await opener.openDocument('./document.docx');

// è½¬æ¢åç«‹å³æ‰“å¼€
await mcpServer.callTool('convert_and_open', {
  markdownPath: './README.md',
  autoSync: true
});

// CLIä½¿ç”¨
// $ npx mdsync convert-open README.md --sync
// $ npx mdsync open document.docx --wait
```

## ğŸ“‹ **å¹³å°å…¼å®¹æ€§æ€»ç»“**

| å¹³å° | æ¨èæ–¹æ³• | å¤‡é€‰æ–¹æ¡ˆ | æ³¨æ„äº‹é¡¹ |
|------|----------|----------|----------|
| **Windows** | `start "" "file.docx"` | `explorer "file.docx"` | è·¯å¾„éœ€è¦åæ–œæ  |
| **macOS** | `open file.docx` | `open -a "Microsoft Word" file.docx` | åº”ç”¨åç§°åŒºåˆ†å¤§å°å†™ |
| **Linux** | `xdg-open file.docx` | `libreoffice file.docx` | éœ€è¦æ¡Œé¢ç¯å¢ƒ |

## ğŸ¯ **ç”¨æˆ·ä½“éªŒä¼˜åŒ–å»ºè®®**

1. **æ·»åŠ æ‰“å¼€å‰çš„ç¡®è®¤**ï¼ˆå¯é€‰ï¼‰
   ```typescript
   const shouldOpen = await this.confirmOpen(filePath);
   if (!shouldOpen) return;
   ```

2. **æ˜¾ç¤ºæ‰“å¼€è¿›åº¦**
   ```typescript
   const spinner = createSpinner('æ­£åœ¨æ‰“å¼€Word...').start();
   // ...æ‰“å¼€æ“ä½œ
   spinner.succeed('å·²æ‰“å¼€ï¼');
   ```

3. **è®°å¿†ç”¨æˆ·é€‰æ‹©**
   ```typescript
   // ä¿å­˜ç”¨æˆ·åå¥½çš„åº”ç”¨
   localStorage.setItem('preferred-word-app', 'wps');
   ```

4. **æä¾›æ‰“å¼€å¤±è´¥çš„è§£å†³æ–¹æ¡ˆ**
   ```typescript
   // å¤±è´¥æ—¶ç»™å‡ºå…·ä½“å»ºè®®
   if (error.code === 'ENOENT') {
     console.log('å»ºè®®: å®‰è£…WPS Office (å…è´¹)');
   }
   ```

